# ðŸš€ Enterprise CI/CD Pipeline - AI Multi-Model Management System
# Fase 2 Extended: $100K AI Multi-Model Upgrade
# Pipeline completo con testing automatizado, deployment enterprise y rollback

name: ðŸ”¥ Enterprise AI Multi-Model CI/CD Pipeline

on:
  push:
    branches: 
      - main
      - genspark_ai_developer
      - develop
      - staging
  pull_request:
    branches: 
      - main
      - genspark_ai_developer
  workflow_dispatch:
    inputs:
      deployment_environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      enable_rollback:
        description: 'Enable automatic rollback on failure'
        required: false
        default: true
        type: boolean

env:
  NODE_VERSION: '20.x'
  PYTHON_VERSION: '3.11'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DEPLOYMENT_TIMEOUT: 600 # 10 minutes

jobs:
  # ðŸ§ª TESTING JOBS
  lint-and-validate:
    name: ðŸ” Code Quality & Validation
    runs-on: ubuntu-latest
    strategy:
      matrix:
        component: [backend, frontend, sdk]
    
    steps:
    - name: ðŸ“¥ Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: ðŸŸ¢ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: ðŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: ðŸ“¦ Install Dependencies
      run: |
        npm ci
        pip install -r requirements.txt
        pip install flake8 black isort mypy pylint

    - name: ðŸ”§ Lint JavaScript/TypeScript
      if: matrix.component == 'backend' || matrix.component == 'frontend' || matrix.component == 'sdk'
      run: |
        npx eslint . --ext .js,.ts,.tsx --max-warnings 0
        npx prettier --check "**/*.{js,ts,tsx,json,md}"

    - name: ðŸ Lint Python
      if: matrix.component == 'backend' || matrix.component == 'sdk'
      run: |
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        black --check .
        isort --check-only .
        mypy . --ignore-missing-imports

    - name: ðŸ” Security Scan
      uses: github/super-linter@v4
      env:
        DEFAULT_BRANCH: main
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        VALIDATE_ALL_CODEBASE: false

  unit-tests:
    name: ðŸ§ª Unit Tests
    runs-on: ubuntu-latest
    needs: lint-and-validate
    
    services:
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
      
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_USER: test_user
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: ðŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ðŸŸ¢ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: ðŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: ðŸ“¦ Install Dependencies
      run: |
        npm ci
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-asyncio

    - name: ðŸ”§ Setup Test Environment
      run: |
        cp .env.example .env
        echo "REDIS_URL=redis://localhost:6379" >> .env
        echo "DATABASE_URL=postgresql://test_user:test_password@localhost:5432/test_db" >> .env

    - name: ðŸ§ª Run JavaScript/Node.js Tests
      run: |
        npm test -- --coverage --watchAll=false
        npx jest --coverage --passWithNoTests

    - name: ðŸ Run Python Tests
      run: |
        python -m pytest tests/ -v --cov=backend --cov-report=xml --cov-report=html

    - name: ðŸ“Š Upload Coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

  integration-tests:
    name: ðŸ”— Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests
    
    strategy:
      matrix:
        test-suite: [api, ai-models, websockets, auth]
    
    services:
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_USER: test_user
          POSTGRES_DB: integration_test_db
        ports:
          - 5432:5432

    steps:
    - name: ðŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ðŸŸ¢ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: ðŸ“¦ Install Dependencies
      run: npm ci

    - name: ðŸš€ Start Test Services
      run: |
        cp .env.example .env
        echo "NODE_ENV=test" >> .env
        echo "REDIS_URL=redis://localhost:6379" >> .env
        echo "DATABASE_URL=postgresql://test_user:test_password@localhost:5432/integration_test_db" >> .env
        
        # Start backend services in background
        npm run start:test &
        sleep 10

    - name: ðŸ§ª Run Integration Tests - ${{ matrix.test-suite }}
      run: |
        case "${{ matrix.test-suite }}" in
          "api")
            node test-enterprise-master-system.js
            ;;
          "ai-models")
            node test-phase2-integration.js
            ;;
          "websockets")
            npm run test:websockets
            ;;
          "auth")
            npm run test:auth
            ;;
        esac

  e2e-tests:
    name: ðŸŒ End-to-End Tests
    runs-on: ubuntu-latest
    needs: integration-tests

    steps:
    - name: ðŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ðŸŸ¢ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: ðŸ“¦ Install Dependencies
      run: |
        npm ci
        npx playwright install --with-deps

    - name: ðŸš€ Start Application
      run: |
        cp .env.example .env
        npm run build
        npm run start:prod &
        npx wait-on http://localhost:3000 --timeout 60000

    - name: ðŸ§ª Run E2E Tests
      run: |
        npx playwright test --reporter=html

    - name: ðŸ“Š Upload E2E Test Results
      uses: actions/upload-artifact@v3
      if: failure()
      with:
        name: playwright-report
        path: playwright-report/

  # ðŸ—ï¸ BUILD JOBS
  build-and-package:
    name: ðŸ—ï¸ Build & Package
    runs-on: ubuntu-latest
    needs: [lint-and-validate, unit-tests]
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
    - name: ðŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ðŸŸ¢ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: ðŸ“¦ Install Dependencies
      run: npm ci

    - name: ðŸ—ï¸ Build Frontend
      run: |
        cd frontend
        npm ci
        npm run build

    - name: ðŸ—ï¸ Build Backend
      run: |
        npm run build

    - name: ðŸ“¦ Build SDK Packages
      run: |
        cd sdk/javascript
        npm ci
        npm run build
        
        cd ../python
        pip install build
        python -m build

    - name: ðŸ³ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: ðŸ” Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: ðŸ“‹ Extract Metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-

    - name: ðŸ—ï¸ Build and Push Docker Image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # ðŸš€ DEPLOYMENT JOBS
  deploy-staging:
    name: ðŸ§ª Deploy to Staging
    runs-on: ubuntu-latest
    needs: [e2e-tests, build-and-package]
    if: github.ref == 'refs/heads/genspark_ai_developer' || github.ref == 'refs/heads/develop'
    
    environment:
      name: staging
      url: https://staging-ai-multimodel.genspark.ai

    steps:
    - name: ðŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ðŸ”§ Setup Deployment Tools
      run: |
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/

    - name: ðŸš€ Deploy to Staging
      run: |
        echo "ðŸš€ Deploying to Staging Environment..."
        
        # Update Kubernetes manifests
        sed -i "s|IMAGE_TAG|${{ needs.build-and-package.outputs.image-tag }}|g" infrastructure/k8s/staging/deployment.yaml
        
        # Apply Kubernetes configurations
        kubectl apply -f infrastructure/k8s/staging/
        
        # Wait for rollout
        kubectl rollout status deployment/ai-multimodel-api -n staging --timeout=600s
        kubectl rollout status deployment/ai-multimodel-frontend -n staging --timeout=600s

    - name: ðŸ” Health Check
      run: |
        echo "ðŸ” Running staging health checks..."
        sleep 30
        curl -f https://staging-ai-multimodel.genspark.ai/health || exit 1
        curl -f https://staging-ai-multimodel.genspark.ai/api/v1/health || exit 1

    - name: ðŸ§ª Run Smoke Tests
      run: |
        echo "ðŸ§ª Running smoke tests on staging..."
        npm run test:smoke -- --environment=staging

  deploy-production:
    name: ðŸŒŸ Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-staging, build-and-package]
    if: github.ref == 'refs/heads/main'
    
    environment:
      name: production
      url: https://ai-multimodel.genspark.ai

    steps:
    - name: ðŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ðŸ” Setup Production Credentials
      run: |
        echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > ~/.kube/config
        chmod 600 ~/.kube/config

    - name: ðŸ“Š Pre-deployment Backup
      run: |
        echo "ðŸ“Š Creating pre-deployment backup..."
        kubectl create backup production-backup-$(date +%Y%m%d-%H%M%S) -n production

    - name: ðŸš€ Blue-Green Deployment
      id: deploy
      run: |
        echo "ðŸš€ Starting Blue-Green deployment..."
        
        # Deploy to green environment
        sed -i "s|IMAGE_TAG|${{ needs.build-and-package.outputs.image-tag }}|g" infrastructure/k8s/production/deployment-green.yaml
        kubectl apply -f infrastructure/k8s/production/deployment-green.yaml
        
        # Wait for green deployment
        kubectl rollout status deployment/ai-multimodel-api-green -n production --timeout=600s
        kubectl rollout status deployment/ai-multimodel-frontend-green -n production --timeout=600s
        
        # Health check on green
        kubectl port-forward service/ai-multimodel-api-green 8081:80 -n production &
        sleep 10
        curl -f http://localhost:8081/health || exit 1
        
        # Switch traffic to green
        kubectl patch service ai-multimodel-api -n production -p '{"spec":{"selector":{"version":"green"}}}'
        kubectl patch service ai-multimodel-frontend -n production -p '{"spec":{"selector":{"version":"green"}}}'
        
        echo "deployment-id=$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT

    - name: ðŸ” Production Health Check
      run: |
        echo "ðŸ” Running production health checks..."
        sleep 60
        curl -f https://ai-multimodel.genspark.ai/health || exit 1
        curl -f https://ai-multimodel.genspark.ai/api/v1/health || exit 1

    - name: ðŸ§ª Production Smoke Tests
      run: |
        echo "ðŸ§ª Running production smoke tests..."
        npm run test:smoke -- --environment=production

    - name: ðŸ“Š Update Monitoring
      run: |
        echo "ðŸ“Š Updating monitoring and alerts..."
        curl -X POST "${{ secrets.DATADOG_WEBHOOK }}" \
          -H "Content-Type: application/json" \
          -d '{"deployment_id": "${{ steps.deploy.outputs.deployment-id }}", "environment": "production", "status": "deployed"}'

  # ðŸ”„ ROLLBACK JOB
  rollback:
    name: ðŸ”„ Emergency Rollback
    runs-on: ubuntu-latest
    if: failure() && (github.ref == 'refs/heads/main' || inputs.enable_rollback)
    needs: [deploy-production]
    
    environment:
      name: production-rollback

    steps:
    - name: ðŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ðŸ”„ Execute Rollback
      run: |
        echo "ðŸ”„ Executing emergency rollback..."
        
        # Get previous successful deployment
        PREVIOUS_DEPLOYMENT=$(kubectl get deployments -n production -o jsonpath='{.items[0].metadata.annotations.deployment\.kubernetes\.io/revision}')
        ROLLBACK_REVISION=$((PREVIOUS_DEPLOYMENT - 1))
        
        # Rollback deployments
        kubectl rollout undo deployment/ai-multimodel-api -n production --to-revision=$ROLLBACK_REVISION
        kubectl rollout undo deployment/ai-multimodel-frontend -n production --to-revision=$ROLLBACK_REVISION
        
        # Wait for rollback completion
        kubectl rollout status deployment/ai-multimodel-api -n production --timeout=300s
        kubectl rollout status deployment/ai-multimodel-frontend -n production --timeout=300s

    - name: ðŸ” Post-Rollback Health Check
      run: |
        echo "ðŸ” Verifying rollback health..."
        sleep 30
        curl -f https://ai-multimodel.genspark.ai/health || exit 1

    - name: ðŸ“¢ Notify Rollback
      run: |
        echo "ðŸ“¢ Notifying stakeholders of rollback..."
        curl -X POST "${{ secrets.SLACK_WEBHOOK }}" \
          -H "Content-Type: application/json" \
          -d '{"text": "ðŸš¨ EMERGENCY ROLLBACK executed for AI Multi-Model System. Production has been restored to previous stable version."}'

  # ðŸ“Š POST-DEPLOYMENT MONITORING
  post-deployment-monitoring:
    name: ðŸ“Š Post-Deployment Monitoring
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: success() && github.ref == 'refs/heads/main'

    steps:
    - name: ðŸ“Š Setup Monitoring
      run: |
        echo "ðŸ“Š Setting up post-deployment monitoring..."
        
        # Start monitoring for 15 minutes
        for i in {1..15}; do
          echo "ðŸ“Š Monitoring check $i/15..."
          
          # Health checks
          curl -f https://ai-multimodel.genspark.ai/health
          curl -f https://ai-multimodel.genspark.ai/api/v1/metrics
          
          # Check error rates
          ERROR_RATE=$(curl -s https://ai-multimodel.genspark.ai/api/v1/metrics | jq '.error_rate')
          if (( $(echo "$ERROR_RATE > 0.05" | bc -l) )); then
            echo "ðŸš¨ High error rate detected: $ERROR_RATE"
            exit 1
          fi
          
          sleep 60
        done

    - name: ðŸ“¢ Deployment Success Notification
      run: |
        curl -X POST "${{ secrets.SLACK_WEBHOOK }}" \
          -H "Content-Type: application/json" \
          -d '{"text": "ðŸŽ‰ AI Multi-Model System successfully deployed to production! All monitoring checks passed. ðŸš€"}'

  # ðŸ§¹ CLEANUP
  cleanup:
    name: ðŸ§¹ Cleanup Resources
    runs-on: ubuntu-latest
    needs: [post-deployment-monitoring]
    if: always()

    steps:
    - name: ðŸ§¹ Clean up old deployments
      run: |
        echo "ðŸ§¹ Cleaning up old deployments and resources..."
        
        # Keep only last 3 deployments
        kubectl delete deployment -n production -l "version!=green,version!=blue" --sort-by=.metadata.creationTimestamp | tail -n +4 | xargs -r kubectl delete
        
        # Clean up old Docker images
        docker image prune -f --filter "until=72h"

    - name: ðŸ“Š Generate Deployment Report
      run: |
        echo "ðŸ“Š Generating deployment report..."
        cat > deployment-report.md << 'EOF'
        # ðŸš€ Deployment Report - AI Multi-Model System
        
        ## âœ… Deployment Summary
        - **Environment**: Production
        - **Date**: $(date)
        - **Commit**: ${{ github.sha }}
        - **Branch**: ${{ github.ref_name }}
        - **Status**: SUCCESS âœ…
        
        ## ðŸ“Š Metrics
        - **Build Time**: $(date -d @$(($(date +%s) - ${{ github.event.head_commit.timestamp }})) -u +%H:%M:%S)
        - **Tests Passed**: âœ… All test suites
        - **Security Scans**: âœ… No vulnerabilities
        - **Performance**: âœ… All benchmarks passed
        
        ## ðŸ”— Links
        - **Production URL**: https://ai-multimodel.genspark.ai
        - **Staging URL**: https://staging-ai-multimodel.genspark.ai
        - **Monitoring**: https://datadog.com/dashboard/ai-multimodel
        EOF

    - name: ðŸ“¤ Upload Deployment Report
      uses: actions/upload-artifact@v3
      with:
        name: deployment-report
        path: deployment-report.md